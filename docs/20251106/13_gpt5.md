Totally agree—both micro-refinements make the MVP sharper without adding scope. Here’s how we’ll lock them in.

---

## 1) Init response validation failure path (explicit)

**Add guard + edge in `:initializing`:**

```
| :initializing | init_response(ok, caps) | invalid_caps | log warn; schedule backoff | :backoff |
```

**Definition of `valid_caps` (MVP, minimal but concrete):**

* `is_map(caps)` **and**
* `caps["protocolVersion"]` (or atom key `:protocolVersion`) is a **string** compatible with our supported version `"2024-11-05"`.
  *Compatibility rule (MVP):* exact match **or** same YYYY-MM (e.g., `"2024-11-05"` == `"2024-11-xx"`). Anything else = invalid.
* (Optional-but-tolerated) capability maps (e.g., `"resources"`, `"tools"`) may be missing; their absence just means “feature not supported,” **not** invalid.

**Invalid examples (backoff):**

* `caps` not a map
* Missing `"protocolVersion"`
* Non-string or clearly incompatible version (e.g., `"2023-07-01"`)

---

## 2) Concurrent `stop/1` calls (no hangs)

We’ll make shutdown idempotent at the API and state levels.

**API note (MVP):**

* Public `stop/1` performs a **call** (`GenServer.call`) to request orderly shutdown; it’s **not** `GenServer.stop/1` (which gives no reply). That ensures callers always get a response.

**State edges updated:**

```
| :starting     | stop                    | -              | reply {:ok, :ok}; exit(normal)                     | :closing |
| :initializing | stop                    | -              | reply {:ok, :ok}; close transport                  | :closing |
| :ready        | stop                    | -              | reply {:ok, :ok}; fail-fast inflight; close        | :closing |
| :backoff      | stop                    | -              | reply {:ok, :ok}; close                            | :closing |
| :closing      | stop                    | -              | reply {:ok, :already_closing}                      | :closing |
```

**Why option B (`{:ok, :already_closing}`):**

* Clear UX (caller knows shutdown is underway)
* Avoids mysterious hangs if a supervisor-triggered stop overlaps an app call
* Keeps return shape consistent and friendly for pipelines

---

## Updated deltas in the state table (for completeness)

**`:initializing` (two success paths + error path):**

```
| :initializing | init_response(ok,caps)    |  valid_caps | store caps; set session data                      | :ready    |
| :initializing | init_response(ok,caps)    | invalid_caps| log warn; schedule backoff                        | :backoff  |
| :initializing | init_response(error)      |             | schedule backoff                                  | :backoff  |
```

**`:closing` concurrent stop handling:**

```
| :closing      | stop                      | -           | reply {:ok, :already_closing}                     | :closing  |
```

*(All previously agreed rows remain unchanged: fail-fast inflight on entering `:closing`; tombstones + drop rules; oversized-frame close; etc.)*

---

### Net effect

* **No undefined init path:** malformed-but-200 OK init now deterministically backs off.
* **No caller hangs on shutdown:** repeated `stop/1` is idempotent and informative.

This keeps the MVP compact while removing two real footguns you’d otherwise chase in QA.

