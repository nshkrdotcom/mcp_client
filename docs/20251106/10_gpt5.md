Amazing catch-all review. Let’s lock the last 5% so implementation is purely mechanical. I’ll answer every “must resolve” with a concrete MVP decision, give the exact numbers/formulas, add the three missing state edges, and finalize the acceptance checklist.

---

## Final MVP decisions (locked)

### 1) Tombstone TTL: **Global, not per-request**

**Decision:** **Option A (global TTL)**

* Tombstones do **not** vary by per-call timeout.
* One global TTL computed from configured defaults at startup:

  ```elixir
  tombstone_ttl =
      request_timeout_default +
      init_timeout_default +
      backoff_max_default +
      5_000
  ```
* Rationale: simple, bounded memory; stale responses after a reconnect window are never delivered anyway. If apps need stronger guarantees, session-IDs are the post-MVP hardening.

---

### 2) Race: response during tombstoning

**Decision:** Document the ordering guarantee.

* gen_statem processes one event at a time. Our transition `:ready → :backoff` (or `:ready → :initializing` on server reset) performs:

  1. Synchronous tombstone insertion for **all** inflight IDs (data mutation),
  2. Then returns `{:next_state, ...}`.
* Only **after** that return will the mailbox deliver any next message (e.g., a late response), which will see the tombstone.
* We’ll add one explicit line in the doc: “Tombstoning of in-flight IDs is atomic with the state transition; late responses arriving after the transition are always seen as tombstoned.”

---

### 3) Jitter: formula + seeding

**Decision:** Lock the formula and seed strategy.

* Seed once in `Connection.init/1`:

  ```elixir
  :rand.seed(:exsplus, {node(), self(), System.monotonic_time()})
  ```
* Jitter helper:

  ```elixir
  defp jitter(ms, factor) do
    # factor = 0.5 ⇒ ±50%
    scale = 1.0 + (:rand.uniform() - 0.5) * (factor * 2.0)
    max(0, round(ms * scale))
  end
  ```
* Backoff progression:

  ```elixir
  next = min(current * 2, backoff_max) |> jitter(0.2)
  ```
* Busy retry delay:

  ```elixir
  retry_delay = jitter(10, 0.5)   # 5–15ms
  ```

---

### 4) Oversized frame handling

**Decision:** **Close immediately**; no JSON-RPC error attempt.

* If `byte_size(frame) > max_frame_bytes`:

  * Log protocol error,
  * **Close transport and transition to `:backoff`**,
  * Do **not** try to extract `id` or send an error (unsafe without full parse).
* Document: “Server may retain dangling state for that message.” (Acceptable for MVP; post-MVP we can add streaming parser to surface `id`.)

---

### 5) Missing state edges (added)

Add these rows to the table:

```
| :starting     | stop                          | -           | exit(normal)                                  | :closing     |
| :initializing | frame(oversized)              | size>max    | close transport; schedule backoff              | :backoff     |
| :ready        | frame(oversized)              | size>max    | close transport; tombstone all; schedule backoff| :backoff     |
```

Also clarify server-wide cancel:

* **Notification method name (MVP):** configurable via `:reset_notification_method` (default: `"notifications/cancelled"`).
* On receiving that method in `:ready`: tombstone-all ⇒ `:initializing`.

---

### 6) Request map shape (locked)

**Decision:** Flat map by ID.

```elixir
%{
  id => %{
    from: from,
    timer_ref: reference(),
    started_at_mono: integer(),
    method: String.t()
  }
}
```

* `params` are not stored (to keep memory bounded); they appear in telemetry only if the caller includes them.

---

### 7) Synchronous notification hazard (MVP)

**Decision:** Keep synchronous; **document exact failure mode**.

* Handlers run inline; if a handler blocks, the connection cannot read/process the next frame (backpressure propagates to transport).
* Doc sentence to ship:
  “Notification handlers must be fast (<5ms typical). Long-running work will stall the connection (mailbox growth, missed pings, delayed responses). Move heavy work off-thread in your application (Task, GenServer) and return immediately.”

(No hard timeout in MVP; adding a TaskSupervisor is the post-MVP upgrade.)

---

### 8) Supervision tree (final)

**Decision:** Exactly **two** children, no links, `:rest_for_one`.

```
ConnectionSupervisor (rest_for_one)
  ├─ Transport  (worker)
  └─ Connection (worker)  # starts last
```

* All timers (init timeout, backoff, request timeouts, sweeps) live **inside Connection**.

---

### 9) Tombstone cleanup strategy

**Decision:** **Periodic sweep** (Option C).

* One timer (state/event timeout) every **60s**:

  * Remove entries whose `(now_mono - inserted_at) > tombstone_ttl`.
* Lookup still checks TTL to avoid false positives between sweeps.

---

### 10) Graceful shutdown semantics

**Decision:** **Fail-fast** on entering `:closing`.

* Iterate inflight requests and reply:

  ```elixir
  {:error, %Error{kind: :shutdown, message: "client shutting down"}}
  ```
* Insert tombstones for those IDs (optional but cheap), then close transport.

---

## Property test parameters (locked)

```elixir
@property_iterations 100
@max_concurrent_requests 50
@max_reorder_window_ms 100
@cancellation_attempts 5
```

* Use fixed seed in CI for reproducibility (print seed on failure).

---

## Final state transition table (with added rows)

```
| Current        | Event                               | Guard/Notes                         | Action                                                                | Next         |
|----------------|-------------------------------------|-------------------------------------|-----------------------------------------------------------------------|--------------|
| :starting      | :spawn_ok                           |                                     | start init; arm init_timeout                                          | :initializing|
| :starting      | :spawn_error(reason)                |                                     | schedule backoff(1st); log                                            | :backoff     |
| :starting      | stop                                |                                     | exit(normal)                                                          | :closing     |
| :starting      | user_call(...)                      |                                     | {:error, %Error{kind: :state, data: %{state: :starting}}}            | :starting    |

| :initializing  | init_response(ok,caps)              | valid caps                          | store caps; set session data                                          | :ready       |
| :initializing  | init_response(error)                |                                     | schedule backoff                                                      | :backoff     |
| :initializing  | init_timeout                        |                                     | schedule backoff                                                      | :backoff     |
| :initializing  | transport_down(reason)              |                                     | schedule backoff                                                      | :backoff     |
| :initializing  | frame(oversized)                    | size > max_frame_bytes              | close transport; schedule backoff                                     | :backoff     |
| :initializing  | frame(other)                        |                                     | drop; set_active(:once)                                               | :initializing|
| :initializing  | user_call(...)                      |                                     | {:error, %Error{kind: :state, data: %{state: :initializing}}}        | :initializing|
| :initializing  | stop                                |                                     | close                                                                 | :closing     |

| :ready         | response(id)                        | id in requests                      | deliver, clear timer/id; set_active(:once)                            | :ready       |
| :ready         | response(id)                        | id in tombstones                    | drop; set_active(:once)                                               | :ready       |
| :ready         | response(id)                        | id unknown                          | warn & drop; set_active(:once)                                        | :ready       |
| :ready         | server_notification(reset)          | method == reset_notification_method | tombstone-all; clear requests; start init                              | :initializing|
| :ready         | transport_down(reason)              |                                     | tombstone-all; clear requests; schedule backoff                       | :backoff     |
| :ready         | frame(oversized)                    | size > max_frame_bytes              | close transport; tombstone-all; schedule backoff                      | :backoff     |
| :ready         | user_call(method, params, opts)     |                                     | make id; store row; send_frame w/ retry(3, 10ms±50%); start timer     | :ready       |
| :ready         | request_timeout(id)                 | id present                          | reply timeout; send cancel; insert tombstone                          | :ready       |
| :ready         | stop                                |                                     | reply shutdown to inflight; tombstone-all; close                      | :closing     |

| :backoff       | backoff_expire                      |                                     | restart transport; start init                                         | :initializing|
| :backoff       | transport_up                        |                                     | start init                                                            | :initializing|
| :backoff       | frame(_)                            |                                     | drop                                                                   | :backoff     |
| :backoff       | user_call(...)                      |                                     | {:error, %Error{kind: :state, data: %{state: :backoff}}}             | :backoff     |
| :backoff       | stop                                |                                     | close                                                                  | :closing     |

| :closing       | any                                 |                                     | drop                                                                   | :closing     |
```

---

## Numeric defaults (unchanged, now “committed”)

```elixir
@defaults [
  request_timeout: 30_000,
  init_timeout: 10_000,
  backoff_min: 1_000,
  backoff_max: 30_000,    # jittered ±20%
  max_frame_bytes: 16_777_216,  # 16MB
  retry_attempts: 3,      # send_frame busy retries
  retry_delay_ms: 10,     # jittered ±50%
  tombstone_ttl: :computed_global  # formula above
]
```

---

## Super short “What’s NOT in MVP”

* No session-ID gating (late-stale hardening).
* No async notification dispatch or TaskSupervisor.
* No transport diagnostics/stats API.
* No connection pooling or shared subscription registry.
* No negotiation of max frame size.

---

## Acceptance checklist (all items answered)

* [x] Tombstone TTL policy: **Global** (computed).
* [x] Ordering guarantee: **documented** (atomic transition).
* [x] Jitter seeding & formula: **locked**.
* [x] Oversized frames: **close**; no attempt to send error.
* [x] State edges: **added** (oversized + starting/stop).
* [x] Request map shape: **locked** (`%{from,timer_ref,started_at_mono,method}`).
* [x] Notifications: **sync**, documented failure mode.
* [x] Supervision: **exactly 2 children** (Transport, Connection).
* [x] Tombstone cleanup: **periodic sweep** every 60s (+ TTL check on lookup).
* [x] Graceful shutdown: **fail-fast** with `%Error{kind: :shutdown}`.
* [x] Property test params: **locked** (see numbers above).

---

If you want, I can drop this into a ready-to-commit `design/MVP_SPEC.md` and a `connection_state_table.md` so contributors have one canonical source.
